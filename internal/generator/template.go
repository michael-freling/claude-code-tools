// Package generator provides template generation and management functionality for Claude Code tools.
// It supports generating skills, agents, commands, and rules from embedded templates with
// customizable options and metadata-driven configuration.
package generator

import (
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/michael-freling/claude-code-tools/internal/templates"
	"gopkg.in/yaml.v3"
)

// ItemType represents the type of item to generate
type ItemType string

const (
	ItemTypeSkill   ItemType = "skill"
	ItemTypeAgent   ItemType = "agent"
	ItemTypeCommand ItemType = "command"
	ItemTypeRule    ItemType = "rule"
)

// TemplateData holds data to pass to templates
type TemplateData struct {
	Name string
	Type ItemType
}

// RuleTemplateData holds data to pass to rule templates
type RuleTemplateData struct {
	Name        string   // Template name (e.g., "golang")
	Title       string   // Human-readable title (e.g., "Go Coding Guidelines")
	Description string   // Brief description
	Paths       []string // Glob patterns for path restrictions
}

// GenerateOptions holds options for generating templates.
// It allows customization of template generation behavior, such as overriding
// default path patterns from metadata.
type GenerateOptions struct {
	Paths []string // Override default paths from rule metadata
}

// RuleMetadata defines metadata for a single rule template.
// It contains configuration for how a rule should be generated and used,
// including its display name, description, output filename, and default path patterns.
type RuleMetadata struct {
	Name        string   `yaml:"name"`        // Human-readable display name
	Description string   `yaml:"description"` // Brief description of the rule's purpose
	Filename    string   `yaml:"filename"`    // Output filename when generating the rule
	Paths       []string `yaml:"paths"`       // Default glob patterns for path restrictions
}

// RulesConfig holds configuration for all rules.
// It defines which rules should be generated by default and provides metadata
// for each available rule template.
type RulesConfig struct {
	DefaultRules []string                `yaml:"default_rules"` // List of rules to generate during init
	Rules        map[string]RuleMetadata `yaml:"rules"`         // Metadata for each available rule
}

var templatesFS = templates.FS

// pathsToYAML converts a string slice of paths to a comma-separated string
// suitable for the paths field in Claude Code rule frontmatter.
// For example: ["**/*.go", "**/*.mod"] becomes "**/*.go, **/*.mod"
func pathsToYAML(paths []string) string {
	if len(paths) == 0 {
		return ""
	}
	return strings.Join(paths, ", ")
}

// Engine holds parsed templates and provides generation capabilities
type Engine struct {
	templates     map[ItemType]*template.Template
	templateNames map[ItemType][]string
	rulesConfig   *RulesConfig
}

// NewEngine creates a new template engine by loading and parsing all templates from embedded FS
func NewEngine() (*Engine, error) {
	return NewEngineWithFS(templatesFS)
}

// NewEngineWithFS creates a new template engine by loading and parsing all templates from the provided FS
func NewEngineWithFS(fsys fs.FS) (*Engine, error) {
	engine := &Engine{
		templates:     make(map[ItemType]*template.Template),
		templateNames: make(map[ItemType][]string),
	}

	itemTypes := []ItemType{ItemTypeSkill, ItemTypeAgent, ItemTypeCommand, ItemTypeRule}

	for _, itemType := range itemTypes {
		tmpl, names, err := loadTemplatesForType(fsys, itemType)
		if err != nil {
			return nil, fmt.Errorf("failed to load templates for %s: %w", itemType, err)
		}
		engine.templates[itemType] = tmpl
		engine.templateNames[itemType] = names
	}

	// Load rules metadata if rules directory exists
	rulesConfig, err := loadRuleMetadata(fsys)
	if err != nil {
		return nil, fmt.Errorf("failed to load rule metadata: %w", err)
	}
	engine.rulesConfig = rulesConfig

	return engine, nil
}

// loadTemplatesForType loads all templates for a specific item type from the provided FS
func loadTemplatesForType(fsys fs.FS, itemType ItemType) (*template.Template, []string, error) {
	dir := fmt.Sprintf("prompts/%ss", itemType)

	// Check if directory exists
	entries, err := fs.ReadDir(fsys, dir)
	if err != nil {
		// Directory doesn't exist, return empty template set
		return template.New(string(itemType)), []string{}, nil
	}

	var tmpl *template.Template

	// First pass: parse type-specific _partials.tmpl from the type's directory
	typePartialsPath := filepath.Join(dir, "_partials.tmpl")
	partialsContent, err := fs.ReadFile(fsys, typePartialsPath)
	if err == nil {
		tmpl = template.New(string(itemType)).Funcs(template.FuncMap{
			"pathsToYAML": pathsToYAML,
		})
		tmpl, err = tmpl.Parse(string(partialsContent))
		if err != nil {
			return nil, nil, fmt.Errorf("failed to parse type-specific partials: %w", err)
		}
	} else {
		tmpl = template.New(string(itemType)).Funcs(template.FuncMap{
			"pathsToYAML": pathsToYAML,
		})
	}

	// Track template names from actual template files (not partials)
	var templateNames []string

	// Second pass: parse all other .tmpl files
	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".tmpl") {
			continue
		}

		// Skip _partials.tmpl as it's already parsed
		if entry.Name() == "_partials.tmpl" {
			continue
		}

		filePath := filepath.Join(dir, entry.Name())
		content, err := fs.ReadFile(fsys, filePath)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to read template file %s: %w", filePath, err)
		}

		// Extract template name from filename (remove .tmpl extension)
		templateName := strings.TrimSuffix(entry.Name(), ".tmpl")
		templateNames = append(templateNames, templateName)

		// Parse template with the derived name
		_, err = tmpl.New(templateName).Parse(string(content))
		if err != nil {
			return nil, nil, fmt.Errorf("failed to parse template %s: %w", filePath, err)
		}
	}

	return tmpl, templateNames, nil
}

// Generate executes a specific template and returns the result
func (e *Engine) Generate(itemType ItemType, name string) (string, error) {
	tmpl, ok := e.templates[itemType]
	if !ok {
		return "", fmt.Errorf("no templates found for type: %s", itemType)
	}

	// Check if the specific template exists
	templateToExecute := tmpl.Lookup(name)
	if templateToExecute == nil {
		return "", fmt.Errorf("template %s not found for type %s", name, itemType)
	}

	var result strings.Builder
	var data interface{}

	if itemType == ItemTypeRule {
		// For rules, use RuleTemplateData with metadata
		metadata, ok := e.rulesConfig.Rules[name]
		if !ok {
			// If metadata not found, use default values
			metadata = RuleMetadata{
				Name:        name,
				Description: "",
				Filename:    "",
				Paths:       []string{},
			}
		}

		data = RuleTemplateData{
			Name:        name,
			Title:       metadata.Name,
			Description: metadata.Description,
			Paths:       metadata.Paths,
		}
	} else {
		// For other types, use TemplateData
		data = TemplateData{
			Name: name,
			Type: itemType,
		}
	}

	err := templateToExecute.Execute(&result, data)
	if err != nil {
		return "", fmt.Errorf("failed to execute template %s: %w", name, err)
	}

	return result.String(), nil
}

// List returns available template names for a given item type
func (e *Engine) List(itemType ItemType) []string {
	names, ok := e.templateNames[itemType]
	if !ok {
		return []string{}
	}

	return names
}

// GetRulesConfig returns the loaded rules configuration
func (e *Engine) GetRulesConfig() *RulesConfig {
	return e.rulesConfig
}

// GetDefaultRules returns the list of default rules from configuration.
// These are the rules that will be generated when running 'generator rules init'
// without specifying specific rules. Returns an empty slice if no configuration is loaded
// or no default rules are defined.
func (e *Engine) GetDefaultRules() []string {
	if e.rulesConfig == nil {
		return []string{}
	}
	return e.rulesConfig.DefaultRules
}

// GenerateRuleWithOptions generates a rule with custom options.
// It executes the named rule template and returns the generated content as a string.
// The opts parameter allows overriding default paths from the rule's metadata.
// Returns an error if the rule template is not found or if template execution fails.
func (e *Engine) GenerateRuleWithOptions(name string, opts GenerateOptions) (string, error) {
	tmpl, ok := e.templates[ItemTypeRule]
	if !ok {
		return "", fmt.Errorf("no templates found for type: %s", ItemTypeRule)
	}

	templateToExecute := tmpl.Lookup(name)
	if templateToExecute == nil {
		return "", fmt.Errorf("template %s not found for type %s", name, ItemTypeRule)
	}

	metadata, ok := e.rulesConfig.Rules[name]
	if !ok {
		metadata = RuleMetadata{
			Name:        name,
			Description: "",
			Filename:    "",
			Paths:       []string{},
		}
	}

	paths := metadata.Paths
	if len(opts.Paths) > 0 {
		paths = opts.Paths
	}

	data := RuleTemplateData{
		Name:        name,
		Title:       metadata.Name,
		Description: metadata.Description,
		Paths:       paths,
	}

	var result strings.Builder
	err := templateToExecute.Execute(&result, data)
	if err != nil {
		return "", fmt.Errorf("failed to execute template %s: %w", name, err)
	}

	return result.String(), nil
}

// InitRulesDirectory generates all specified rules to files in the given directory.
// It creates the directory if it doesn't exist and generates each rule as a separate file.
// The force parameter controls whether existing files should be overwritten.
// Returns an error if directory creation fails, rule generation fails, or if a file exists
// and force is false.
func (e *Engine) InitRulesDirectory(dir string, rules []string, force bool) error {
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", dir, err)
	}

	for _, ruleName := range rules {
		content, err := e.Generate(ItemTypeRule, ruleName)
		if err != nil {
			return fmt.Errorf("failed to generate rule %s: %w", ruleName, err)
		}

		metadata, ok := e.rulesConfig.Rules[ruleName]
		filename := fmt.Sprintf("%s.md", ruleName)
		if ok && metadata.Filename != "" {
			filename = filepath.Base(metadata.Filename)
		}

		outputPath := filepath.Join(dir, filename)

		if !force {
			if _, err := os.Stat(outputPath); err == nil {
				return fmt.Errorf("file %s already exists (use --force to overwrite)", outputPath)
			}
		}

		if err := os.WriteFile(outputPath, []byte(content), 0644); err != nil {
			return fmt.Errorf("failed to write file %s: %w", outputPath, err)
		}

		fmt.Printf("Created %s\n", outputPath)
	}

	return nil
}

// loadRuleMetadata loads the _metadata.yaml file from the rules directory
func loadRuleMetadata(fsys fs.FS) (*RulesConfig, error) {
	metadataPath := "prompts/rules/_metadata.yaml"

	data, err := fs.ReadFile(fsys, metadataPath)
	if err != nil {
		// If metadata file doesn't exist, return empty config
		return &RulesConfig{
			DefaultRules: []string{},
			Rules:        make(map[string]RuleMetadata),
		}, nil
	}

	var config RulesConfig
	err = yaml.Unmarshal(data, &config)
	if err != nil {
		return nil, fmt.Errorf("failed to parse metadata file: %w", err)
	}

	// Initialize Rules map if nil
	if config.Rules == nil {
		config.Rules = make(map[string]RuleMetadata)
	}

	// Initialize DefaultRules if nil
	if config.DefaultRules == nil {
		config.DefaultRules = []string{}
	}

	return &config, nil
}
