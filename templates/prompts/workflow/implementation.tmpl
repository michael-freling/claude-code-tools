You are implementing the following plan:

## Plan Summary
{{.Summary}}

## Architecture
{{.Architecture.Overview}}

Components:
{{range .Architecture.Components}}- {{.}}
{{end}}

## Phases
{{range .Phases}}
### {{.Name}}
{{.Description}}
Estimated: {{.EstimatedFiles}} files, {{.EstimatedLines}} lines
{{end}}

## Work Streams
{{range .WorkStreams}}
### {{.Name}}
{{range .Tasks}}- {{.}}
{{end}}{{if .DependsOn}}
Dependencies: {{range .DependsOn}}{{.}} {{end}}
{{end}}
{{end}}

## Risks to Consider
{{range .Risks}}- {{.}}
{{end}}

## CRITICAL: Use Task Tool for Subagent Work

**You MUST use the Task tool to spawn subagents for implementation.** Do NOT implement directly - delegate to the appropriate subagent type.

Available subagent types for the Task tool:
- `software-architect`: For architecture analysis and design
- `golang-engineer`: For Go code implementation with tests
- `typescript-engineer`: For TypeScript/Next.js implementation with tests
- `golang-code-reviewer`: For reviewing Go code changes
- `typescript-code-reviewer`: For reviewing TypeScript code changes
- `Explore`: For codebase exploration and research

### Implementation Process

For each task in the work streams above:

1. **Implement with Engineer Subagent**
   Use Task tool with `subagent_type: "golang-engineer"` or `"typescript-engineer"` (based on tech stack).
   Include in the prompt:
   - The specific task to implement
   - Instructions to write tests alongside implementation
   - Instructions to follow existing codebase patterns

2. **Review with Reviewer Subagent**
   Use Task tool with `subagent_type: "golang-code-reviewer"` or `"typescript-code-reviewer"`.
   Include in the prompt:
   - The files that were changed
   - Instructions to validate code quality
   - Instructions to ensure tests are adequate

3. **Commit after review approval**

## Instructions
1. Use Task tool to delegate implementation to appropriate engineer subagents
2. Use Task tool to delegate code review to reviewer subagents
3. Follow existing codebase patterns and conventions
4. Write comprehensive tests for all new code
5. Ensure all error cases are handled
6. Add appropriate documentation

## Verification Process
After you implement the changes:
1. Commit all your changes with descriptive commit messages
2. Pre-commit hooks will automatically run to check code quality
3. If pre-commit fails, you will receive the error output and must fix all issues
4. After pre-commit passes, push your branch and create a Pull Request:
   - Push the branch: `git push -u origin <branch-name>`
   - Create a PR: `gh pr create --title "<descriptive title>" --body "<description>"`
   - If PR creation fails, you MUST stop and report the error - do NOT continue without a PR
   - Extract the PR number from the PR URL (format: https://github.com/owner/repo/pull/NUMBER)
5. CI will run on the PR to verify the build and tests
6. If CI fails, you will receive the failure details and must fix all issues
7. This process continues until all checks pass

Make sure your implementation:
- Passes all linting and formatting checks
- Compiles without errors
- All tests pass

## Output Format
After completing the implementation and creating the PR, output a summary as JSON with the following structure:
{
  "filesChanged": ["file1.go", "file2.go"],
  "linesAdded": 350,
  "linesRemoved": 20,
  "testsAdded": 15,
  "prNumber": 123,
  "prUrl": "https://github.com/owner/repo/pull/123",
  "summary": "Brief summary of what was implemented",
  "nextSteps": ["optional", "next", "steps"]
}

**IMPORTANT:** You MUST create a Pull Request and include the `prNumber` and `prUrl` in your output. The CI checks require a PR to exist.

Focus on:
- Clean, maintainable code
- Comprehensive error handling
- Table-driven tests with good coverage
- Clear comments only where necessary
